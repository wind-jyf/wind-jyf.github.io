<h1 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h1><p>先来放张图片</p>
<p><img src="1.png" alt="1"></p>
<h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ul>
<li>prototype</li>
<li>_proto_</li>
<li>constructor</li>
<li>实例与原型</li>
<li>原型链</li>
<li>继承</li>
<li>new运算符的实现</li>
</ul>
<h4 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h4><ol>
<li>JS是一种基于原型的语言，每个对象拥有一个原型对象</li>
<li>对象以其原型为模板，从原型继承方法和属性</li>
<li>这些属性和方法定义在对象的构造器函数的prototype属性上，而非对象实例本身</li>
</ol>
<h6 id="构造函数与其原型的关系"><a href="#构造函数与其原型的关系" class="headerlink" title="构造函数与其原型的关系"></a>构造函数与其原型的关系<img src="file:///D:%5C2443165638%5CImage%5CC2C%5C78D27AB8118EF08136D344E24FAFFF5A.png" alt="img"></h6><ul>
<li>每个函数都会有一个prototype属性，并且这个属性指向了一个对象</li>
<li>并且在new的时候，将这个对象设为此实例的原型，也就是_proto_的指向</li>
</ul>
<h4 id="proto"><a href="#proto" class="headerlink" title="_proto_"></a>_proto_</h4><ul>
<li>每一个JS对象（除了null）都具有的一个属性，叫_proto_</li>
<li>这个属性会指向该对象的原型</li>
</ul>
<p>注：实例对象和构造函数均可以指向原型，那原型是否有属性指向构造函数或实例呢？</p>
<h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><ul>
<li>原型可以通过constructor指向构造函数</li>
<li>但是原型不可以指向实例</li>
</ul>
<h4 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h4><ul>
<li><p>当读取实例的属性时，如果找不到，就会查找原型中的属性，一直向上查找</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">parent3</span>(<span class="params">age</span>)</span>{
    <span class="keyword">return</span>{
        age
    }
}

<span class="keyword">var</span> p3 = parent3(<span class="number">50</span>);
<span class="built_in">console</span>.log(p3.constructor);<span class="comment">//[Function: Object]</span></code></pre>
<p>注：其实在实例中，并没有constructor属性，于是查找其原型，发现有constructor属性，且指向构造函数</p>
</li>
</ul>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><ul>
<li>刚刚说原型也是一个对象，那么原型的原型是什么呢</li>
<li>对象和构造函数不同，所以原型链其实是通过_proto_实现的</li>
<li>理解构造函数与对象的区别</li>
<li>构造函数也就是一个函数，每个函数都会有prototype属性指向原型对象</li>
<li>而每个对象都会有_proto_属性，不会指向构造函数，只会指向对象</li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承其实意味着赋值操作，但是JS并不会赋值对象的属性，只是在两个对象之间创建一个关联，所以另一个对象可以通过委托访问另一个对象的属性和函数</p>
<h6 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h6><ul>
<li>instanceof的原理是判断其原型是否在原型链上</li>
</ul>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>{
    <span class="keyword">return</span> <span class="string">'foo'</span>;
}
Foo.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="keyword">return</span> <span class="string">'method'</span>;
}
<span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>)</span>{
    <span class="keyword">return</span> <span class="string">'bar'</span>;
}
<span class="keyword">const</span> foo = <span class="keyword">new</span> Foo();
Bar.prototype = foo; <span class="comment">//继承</span>
<span class="keyword">const</span> bar = <span class="keyword">new</span> Bar();
<span class="built_in">console</span>.log(bar <span class="keyword">instanceof</span> Foo);<span class="comment">//true</span>

<span class="comment">//因为Object.getPrototypeOf(bar) === Foo.prototype</span></code></pre>
<ul>
<li>重写instanceof</li>
</ul>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">instanceof_of</span>(<span class="params">L,R</span>)</span>{
    <span class="keyword">var</span> O = R.prototype;
    L = <span class="built_in">Object</span>.getPrototypeOf(L);
    <span class="keyword">while</span>(<span class="literal">true</span>){
        <span class="keyword">if</span>(L === <span class="literal">null</span>){
            <span class="keyword">return</span> <span class="literal">false</span>  <span class="comment">//找到原型链的最底层，也未找到，所以不在其原型链上</span>
        }
        <span class="keyword">if</span>(O === L){
            <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">//一旦找到，便返回true</span>
        }
        L = <span class="built_in">Object</span>.getPrototypeOf(L);<span class="comment">//顺着原型链向下找</span>
    }
}
<span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>)</span>{} 
<span class="function"><span class="keyword">function</span> <span class="title">D</span>(<span class="params"></span>)</span>{} 

<span class="keyword">var</span> o = <span class="keyword">new</span> C();

<span class="built_in">console</span>.log(instanceof_of(o, C)); <span class="comment">// true</span>
<span class="built_in">console</span>.log(instanceof_of(o, D)); <span class="comment">// false</span></code></pre>
<ul>
<li>使用new实现继承</li>
</ul>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>{
    <span class="keyword">this</span>.value = <span class="string">'animal'</span>;
}

Animal.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="keyword">return</span> <span class="keyword">this</span>.value +<span class="string">' c'</span>+ <span class="string">'is running'</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>)</span>{}

<span class="comment">//这里是关键，创建Animal的实例，并将该实例，并将该实例赋值给Cat.prototype</span>
<span class="comment">//相当于Cat.prototype._protp_ = Animal.prototype</span>
Cat.prototype = <span class="keyword">new</span> Animal();
<span class="keyword">const</span> cat = <span class="keyword">new</span> Cat();
<span class="built_in">console</span>.log(cat.value);<span class="comment">//animal</span></code></pre>
<p>图解：绿色这条链便是原型链继承</p>
<p><img src="file:///D:%5C2443165638%5CImage%5CC2C%5C5D7359FB3ECEBD9ABEE3E5CC90B555BC.png" alt="img"></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="new实现"><a href="#new实现" class="headerlink" title="new实现"></a>new实现</h4><p>new创建的实例有两大特性</p>
<ul>
<li>访问到构造函数里的属性</li>
<li>访问原型链里的属性</li>
</ul>
<p>模拟实现：当new Foo()执行时，会发生以下事情：</p>
<ol>
<li><p>一个继承自Foo.prototype的新对象被创建</p>
</li>
<li><p>使用指定参数调用构造函数</p>
</li>
<li><p>由构造函数返回的对象就是new表达式的结果。如果</p>
<p>构造函数没有显式返回一个对象，则使用步骤一创建的对象</p>
</li>
</ol>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>)</span>{
     <span class="comment">//新建空对象</span>
     <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();

     <span class="comment">//获得构造函数,arguments中去除第一个参数</span>
     Con = [].shift.call(<span class="built_in">arguments</span>);<span class="comment">//也就是说，对arguments执行shift方法</span>
     <span class="comment">//Con拿到了第一个参数即构造函数，并且arguments删除了第一个参数</span>

     <span class="comment">//原型链进行链接</span>
     <span class="built_in">Object</span>.setPrototypeOf(obj,Con.prototype);

     <span class="comment">//绑定this实现继承，obj可以访问到构造函数中的属性</span>
     Con.apply(obj,<span class="built_in">arguments</span>);

     <span class="comment">//返回对象</span>
     <span class="keyword">return</span> obj;
 }

 <span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">color</span>)</span>{
     <span class="keyword">this</span>.color = color;
 }

 Car.prototype.start = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
     <span class="built_in">console</span>.log(<span class="keyword">this</span>.color + <span class="string">" car start"</span>);
 }

 <span class="keyword">var</span> car = create(Car,<span class="string">"black"</span>);
 <span class="built_in">console</span>.log(car.color);<span class="comment">//black</span>
 car.start();<span class="comment">//black car start</span></code></pre>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ol>
<li>理解构造函数的原型和对象的原型并不是一回事</li>
<li>原型链是基于对象上的，和构造函数无关，所以和prototype无关</li>
<li>函数本身就会有prototype属性，指向一个对象。new实例的时候，需要将实例的原型链链上构造函数所指的对象</li>
<li>继承并不是赋值属性，而是将两者存在一种关系，连接起来，可以访问，原型链继承就是这样实现的。</li>
</ol>
<hr>
<p><strong><em>End</em></strong></p>
<p><strong><em>by wind-jyf</em></strong></p>
